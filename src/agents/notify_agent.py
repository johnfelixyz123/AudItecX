"""NotifyAgent coordinates outbound notifications for audit runs."""
from __future__ import annotations

import csv
import json
import shutil
import tempfile
import zipfile
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

from src.mcp_adapters import github_adapter, email_adapter
from src.packager import OUT_DIR


@dataclass
class NotificationResult:
    run_id: str
    github_issue_path: str | None
    email_preview_path: str | None


class NotifyAgent:
    """Dispatch notifications via adapter stubs."""

    def __init__(self, output_dir: Path | None = None) -> None:
        self.github = github_adapter
        self.email = email_adapter
        self.output_dir = Path(output_dir) if output_dir else OUT_DIR
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def notify(
        self,
        run_id: str,
        summary_text: str,
        manifest: Dict[str, Any],
        email: Optional[str] = None,
    ) -> NotificationResult:
        issue_title = f"Audit Run {run_id}"
        issue_body = self._build_issue_body(summary_text, manifest)
        issue = self.github.create_issue(issue_title, issue_body)
        issue_path = issue.get("url")

        email_path = None
        if email:
            subject = f"AudItecX Summary {run_id}"
            email_result = self.email.send_email(email, subject, summary_text)
            email_path = email_result.get("path")

        return NotificationResult(
            run_id=run_id,
            github_issue_path=issue_path,
            email_preview_path=email_path,
        )

    def prepare_package(self, context: Dict[str, Any], run_id: str) -> Path:
        """Compile evidence into a zip archive and return the path."""
        tmp_root = Path(tempfile.mkdtemp(prefix=f"auditecx_{run_id}_"))
        package_dir = tmp_root / "package"
        docs_dir = package_dir / "documents"
        package_dir.mkdir(parents=True, exist_ok=True)
        docs_dir.mkdir(parents=True, exist_ok=True)

        documents = _normalise_records(context.get("documents", []))
        journal_rows = list(context.get("journal_entries", []))
        summary_text = context.get("summary_text") or context.get("summary") or "Summary not provided."

        for doc in documents:
            source = Path(doc.get("path", ""))
            target = docs_dir / doc.get("filename", source.name or "document.txt")
            if source.exists():
                shutil.copy2(source, target)
            else:
                target.write_text(doc.get("text", ""), encoding="utf-8")

        (package_dir / "summary.md").write_text(summary_text, encoding="utf-8")

        journal_csv = package_dir / "journal_entries_used.csv"
        if journal_rows:
            fieldnames = sorted({key for row in journal_rows for key in row.keys()})
            with journal_csv.open("w", encoding="utf-8", newline="") as fh:
                writer = csv.DictWriter(fh, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(journal_rows)
        else:
            journal_csv.write_text("entry_id,vendor_id,invoice_id,po_id,amount,currency,posting_date\n", encoding="utf-8")

        manifest_path = package_dir / "manifest.json"
        manifest_payload = {
            "run_id": run_id,
            "documents": documents,
            "journal_entries": journal_rows,
            "metadata": {key: value for key, value in context.items() if key not in {"documents", "journal_entries"}},
        }
        manifest_path.write_text(json.dumps(manifest_payload, indent=2), encoding="utf-8")

        zip_path = self.output_dir / f"package_{run_id}.zip"
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as archive:
            for file_path in package_dir.rglob("*"):
                if file_path.is_file():
                    archive.write(file_path, file_path.relative_to(package_dir))

        shutil.rmtree(tmp_root, ignore_errors=True)
        return zip_path

    def send_package(
        self,
        run_manifest: Dict[str, Any],
        recipient_email: str,
        body_text: Optional[str] = None,
        attachments: Iterable[Path | str] | None = None,
    ) -> Dict[str, Any]:
        """Relay the prepared package via email adapter without real sending."""
        subject = f"AudItecX Package {run_manifest.get('run_id', '')}"
        body = body_text or "See attached audit package generated by AudItecX."
        attachment_paths = [Path(item) for item in attachments or []]

        if hasattr(self.email, "send"):
            if getattr(self.email, "USE_MOCK", True):
                return self.email.send(recipient_email, subject, body, attachments=attachment_paths)
            lines = [f"To: {recipient_email}", f"Subject: {subject}", "", body, "", "Attachments:"]
            if attachment_paths:
                lines.extend(str(path) for path in attachment_paths)
            else:
                lines.append("<none>")
            output = "\n".join(lines)
            print(output)  # noqa: T201 - intentional diagnostic output
            return {"status": "preview", "mode": "console", "subject": subject}

        return {"status": "skipped", "reason": "Email adapter unavailable"}

    def _build_issue_body(self, summary_text: str, manifest: Dict[str, Any]) -> str:
        lines: List[str] = ["# Audit Summary", "", summary_text, "", "## Manifest Snapshot"]
        for key, value in manifest.items():
            if isinstance(value, (dict, list)):
                lines.append(f"- {key}: {value}")
            else:
                lines.append(f"- {key}: {value}")
        return "\n".join(lines)


__all__ = ["NotifyAgent", "NotificationResult"]


def _normalise_records(records: Iterable[Any]) -> List[Dict[str, Any]]:
    normalised: List[Dict[str, Any]] = []
    for item in records or []:
        if hasattr(item, "to_dict"):
            normalised.append(dict(item.to_dict()))
        elif isinstance(item, dict):
            normalised.append(dict(item))
    return normalised